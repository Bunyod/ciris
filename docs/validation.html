<html><head><title>Ciris: Encoding Validation</title><meta charset="utf-8" /><meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" /><meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="author" content="Viktor Lövgren" /><meta name="description" content="Lightweight, extensible, and validated configuration loading in Scala" /><meta name="og:image" content="/img/poster.png" /><meta name="og:title" content="Ciris: Encoding Validation" /><meta name="og:site_name" content="Ciris" /><meta name="og:url" content="" /><meta name="og:type" content="website" /><meta name="og:description" content="Lightweight, extensible, and validated configuration loading in Scala" /><link rel="icon" type="image/png" href="/img/favicon.png" /><meta name="twitter:title" content="Ciris: Encoding Validation" /><meta name="twitter:image" content="img/poster.png" /><meta name="twitter:description" content="Lightweight, extensible, and validated configuration loading in Scala" /><meta name="twitter:card" content="summary_large_image" /><meta name="twitter:creator" content="@vlovgr" /><link rel="icon" type="image/png" sizes="16x16" href="/img/favicon16x16.png" /><link rel="icon" type="image/png" sizes="24x24" href="/img/favicon24x24.png" /><link rel="icon" type="image/png" sizes="32x32" href="/img/favicon32x32.png" /><link rel="icon" type="image/png" sizes="48x48" href="/img/favicon48x48.png" /><link rel="icon" type="image/png" sizes="57x57" href="/img/favicon57x57.png" /><link rel="icon" type="image/png" sizes="60x60" href="/img/favicon60x60.png" /><link rel="icon" type="image/png" sizes="64x64" href="/img/favicon64x64.png" /><link rel="icon" type="image/png" sizes="70x70" href="/img/favicon70x70.png" /><link rel="icon" type="image/png" sizes="72x72" href="/img/favicon72x72.png" /><link rel="icon" type="image/png" sizes="76x76" href="/img/favicon76x76.png" /><link rel="icon" type="image/png" sizes="96x96" href="/img/favicon96x96.png" /><link rel="icon" type="image/png" sizes="114x114" href="/img/favicon114x114.png" /><link rel="icon" type="image/png" sizes="120x120" href="/img/favicon120x120.png" /><link rel="icon" type="image/png" sizes="128x128" href="/img/favicon128x128.png" /><link rel="icon" type="image/png" sizes="144x144" href="/img/favicon144x144.png" /><link rel="icon" type="image/png" sizes="150x150" href="/img/favicon150x150.png" /><link rel="icon" type="image/png" sizes="152x152" href="/img/favicon152x152.png" /><link rel="icon" type="image/png" sizes="196x196" href="/img/favicon196x196.png" /><link rel="icon" type="image/png" sizes="310x310" href="/img/favicon310x310.png" /><link rel="icon" type="image/png" sizes="310x150" href="/img/favicon310x150.png" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" /><link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" /><link rel="stylesheet" href="/highlight/styles/atom-one-light.css" /><link rel="stylesheet" href="/css/style.css" /><link rel="stylesheet" href="/css/palette.css" /><link rel="stylesheet" href="/css/codemirror.css" /><link rel="stylesheet" href="/css/custom.css" /></head><body class="docs"><div id="wrapper"><div id="sidebar-wrapper"><ul id="sidebar" class="sidebar-nav"><li class="sidebar-brand"><a href="/" class="brand"><div class="brand-wrapper"><span>Ciris</span></div></a></li> <li><a href="/docs/basics" class="">Usage Basics</a></li> <li><a href="/docs/topics" class="">Configuration Topics</a> <ul class="sub_section"> <li><a href="/docs/validation" class=" active ">Encoding Validation</a></li> <li><a href="/docs/environments" class="">Multiple Environments</a></li> <li><a href="/docs/logging" class="">Logging Configurations</a></li></ul></li> <li><a href="/docs/sources" class="">Configuration Sources</a> <ul class="sub_section"> <li><a href="/docs/supported-sources" class="">Current Supported Sources</a></li> <li><a href="/docs/supporting-new-sources" class="">Supporting New Sources</a></li></ul></li> <li><a href="/docs/decoders" class="">Configuration Decoders</a> <ul class="sub_section"> <li><a href="/docs/supported-types" class="">Current Supported Types</a></li> <li><a href="/docs/supporting-new-types" class="">Supporting New Types</a></li></ul></li> <li><a href="/docs/modules" class="">Modules Overview</a> <ul class="sub_section"> <li><a href="/docs/cats-module" class="">Cats Module</a></li> <li><a href="/docs/cats-effect-module" class="">Cats Effect Module</a></li> <li><a href="/docs/enumeratum-module" class="">Enumeratum Module</a></li> <li><a href="/docs/generic-module" class="">Generic Module</a></li> <li><a href="/docs/refined-module" class="">Refined Module</a></li> <li><a href="/docs/spire-module" class="">Spire Module</a></li> <li><a href="/docs/squants-module" class="">Squants Module</a></li></ul></li> <li><a href="/docs/contributing" class="">Contributing Guide</a></li></ul></div><div id="page-content-wrapper"><div class="nav"><div class="container-fluid"><div class="row"><div class="col-lg-12"><div class="action-menu pull-left clearfix"><a href="#menu-toggle" id="menu-toggle"><i class="fa fa-bars" aria-hidden="true"></i></a></div><ul class="pull-right"><li id="gh-eyes-item" class="hidden-xs"><a href="https://github.com/vlovgr/ciris"><i class="fa fa-eye"></i><span>WATCH<span id="eyes" class="label label-default">--</span></span></a></li><li id="gh-stars-item" class="hidden-xs"><a href="https://github.com/vlovgr/ciris"><i class="fa fa-star-o"></i><span>STARS<span id="stars" class="label label-default">--</span></span></a></li></ul></div></div></div></div><div id="content" data-github-owner="vlovgr" data-github-repo="ciris"><div class="content-wrapper"><section><h1 id="encoding-validation">Encoding Validation</h1>
<p>Ensuring that your configurations are valid can be a tricky challenge. What we’re trying to avoid is <em>latent configuration errors</em><sup id="fnref:1"><a href="#fn:1" class="footnote">1</a></sup> which occur because configuration values are not validated upfront. When trying to use these values, we realize they are unusable, potentially causing all sorts of problems. For example, as seen below, we might accidentally use weak secret keys in our production environment, or try to start our service on ports we should never occupy in the first place.</p>

<p>Ciris approach to avoiding <em>latent configuration errors</em> is to use more precise types for your configuration values, only allowing values which you know are <em>useable</em> to exist in the application. Essentially, values are validated as they are loaded, as part of the configuration loading process, and you’ll end up with a configuration you know is <em>useable</em>. As you’ll see later on, determining what <em>useable</em> means can be difficult on its own, and we’ll discuss how to reason about the concept.</p>

<p>The main thing to remember is that we’re trying to prevent errors where possible, and reduce the possibility of errors where they cannot be fully prevented. Ideally, we want to make only valid configurations representable, and discover <em>invalid</em> configuration values as early as possible. The ultimate goal is to make working with configurations more safe.</p>

<h2 id="precise-configurations">Precise Configurations</h2>
<p>One challenge with loading configuration values is that most values are interpreted as <code class="highlighter-rouge">String</code>s, but that’s rarely the type we want, or should, use to represent values. For example, you probably don’t want to use any <code class="highlighter-rouge">String</code> as an API key (surely not the empty <code class="highlighter-rouge">String</code>, and not too weak keys), and not <code class="highlighter-rouge">String</code> or any <code class="highlighter-rouge">Int</code> for the port number (many port numbers are reserved or require sudo permissions to use).</p>

<p>Ciris encourages you to encode validation by using more precise types, and integrates with several external libraries, like <a href="/docs/enumeratum-module">enumeratum</a>, <a href="/docs/refined-module">refined</a>, and <a href="/docs/squants-module">squants</a>, to be able to decode values into types provided by those libraries. One of the easiest and most convenient ways to use more precise types, is to use <a href="/docs/refined-module">refined</a> and refinement types.</p>

<p>Using refinement types, we can create a type which <em>refines</em> an existing base type by applying a predicate type, which represents the validation logic. For example, we could express a type <code class="highlighter-rouge">ApiKey</code>, which, in this case, is any <code class="highlighter-rouge">String</code> with a length between 25 and 40 characters, and which only contains alphanumeric characters.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">eu.timepit.refined.api.Refined</span>
<span class="k">import</span> <span class="nn">eu.timepit.refined.string.MatchesRegex</span>
<span class="k">import</span> <span class="nn">eu.timepit.refined.W</span>

<span class="k">type</span> <span class="kt">ApiKey</span> <span class="o">=</span> <span class="nc">String</span> <span class="nc">Refined</span> <span class="nc">MatchesRegex</span><span class="o">[</span><span class="kt">W.`</span><span class="err">"</span><span class="o">[</span><span class="kt">a-zA-Z0-</span><span class="err">9</span><span class="o">]{</span><span class="err">25</span>,<span class="err">40</span><span class="o">}</span><span class="err">"</span><span class="kt">`.T</span><span class="o">]</span>
</code></pre>
</div>

<p>By using the <code class="highlighter-rouge">ApiKey</code> type instead of <code class="highlighter-rouge">String</code> whenever we deal with an API key, we can now be confident that the value is not an invalid variant (like the empty <code class="highlighter-rouge">String</code>, or a too weak key, for example). Ciris integrates with refined, so you can load configuration values of type <code class="highlighter-rouge">ApiKey</code> without writing any additional code.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">ciris.</span><span class="o">{</span><span class="n">env</span><span class="o">,</span> <span class="n">prop</span><span class="o">}</span>
<span class="c1">// import ciris.{env, prop}
</span>
<span class="k">import</span> <span class="nn">ciris.refined._</span>
<span class="c1">// import ciris.refined._
</span>
<span class="n">env</span><span class="o">[</span><span class="kt">ApiKey</span><span class="o">](</span><span class="s">"API_KEY"</span><span class="o">).</span>
  <span class="n">orElse</span><span class="o">(</span><span class="n">prop</span><span class="o">(</span><span class="s">"api.key"</span><span class="o">)).</span>
  <span class="n">orNone</span>
<span class="c1">// res0: ciris.ConfigValue[ciris.api.Id,Option[ApiKey]] = ConfigValue$943442388
</span></code></pre>
</div>

<p>Refinement types are also useful for ensuring that configuration values residing in code are valid. Thanks to <a href="/docs/refined-module">refined</a> providing an <code class="highlighter-rouge">auto</code> macro, we can ensure that literal configuration values conform to their predicates at compile-time, and all we have to do is to use the appropriate import. Note that the actual <code class="highlighter-rouge">ApiKey</code> (or any other secret values) shouldn’t be included in code, but rather loaded from, for example, a vault service. The <code class="highlighter-rouge">ApiKey</code> below could, for example, be used in local tests, and would there not be seen as a secret, and could therefore reside in code.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">eu.timepit.refined.auto._</span>
<span class="c1">// import eu.timepit.refined.auto._
</span>
<span class="k">val</span> <span class="n">apiKey</span><span class="k">:</span> <span class="kt">ApiKey</span> <span class="o">=</span> <span class="s">"RacrqvWjuu4KVmnTG9b6xyZMTP7jnX"</span>
<span class="c1">// apiKey: ApiKey = RacrqvWjuu4KVmnTG9b6xyZMTP7jnX
</span></code></pre>
</div>

<p>If the <code class="highlighter-rouge">ApiKey</code> is not valid, we’ll get an error at compile-time.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">apiKey</span><span class="k">:</span> <span class="kt">ApiKey</span> <span class="o">=</span> <span class="s">"changeme"</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">23</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">Predicate</span> <span class="kt">failed:</span> <span class="err">"</span><span class="kt">changeme</span><span class="err">"</span><span class="kt">.matches</span><span class="o">(</span><span class="err">"[</span><span class="kt">a-zA-Z0-</span><span class="err">9]</span><span class="o">{</span><span class="err">25</span><span class="o">,</span><span class="err">40</span><span class="o">}</span><span class="err">"</span><span class="o">).</span>
       <span class="k">val</span> <span class="n">apiKey</span><span class="k">:</span> <span class="kt">ApiKey</span> <span class="o">=</span> <span class="s">"changeme"</span>
                            <span class="o">^</span>
</code></pre>
</div>

<p>If we need to use libraries which doesn’t support our <code class="highlighter-rouge">ApiKey</code> type, we can retrieve the underlying <code class="highlighter-rouge">String</code> value.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="n">apiKey</span><span class="o">.</span><span class="n">value</span>
<span class="c1">// res1: String = RacrqvWjuu4KVmnTG9b6xyZMTP7jnX
</span></code></pre>
</div>

<p>Also, if we want to avoid accidentally logging secrets, we can use <a href="/api/ciris/Secret.html"><code class="highlighter-rouge">Secret</code></a>.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">ciris.Secret</span>
<span class="c1">// import ciris.Secret
</span>
<span class="n">env</span><span class="o">[</span><span class="kt">Secret</span><span class="o">[</span><span class="kt">ApiKey</span><span class="o">]](</span><span class="s">"API_KEY"</span><span class="o">).</span>
  <span class="n">orElse</span><span class="o">(</span><span class="n">prop</span><span class="o">(</span><span class="s">"api.key"</span><span class="o">)).</span>
  <span class="n">orNone</span>
<span class="c1">// res2: ciris.ConfigValue[ciris.api.Id,Option[ciris.Secret[ApiKey]]] = ConfigValue$1833415896
</span></code></pre>
</div>

<p>For more information about <a href="/api/ciris/Secret.html"><code class="highlighter-rouge">Secret</code></a> and logging, refer to the <a href="/docs/logging">logging configurations</a> section.</p>

<p>Refinement types are not limited to <code class="highlighter-rouge">String</code>s, and <a href="/docs/refined-module">refined</a> already includes many common refinement types. One example is <code class="highlighter-rouge">UserPortNumber</code> for <code class="highlighter-rouge">Int</code>s representing port numbers in the closed interval 1024 to 49151. This is a more precise definition of port numbers than <code class="highlighter-rouge">Int</code>, and lets us avoid many reserved port numbers.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">eu.timepit.refined.types.net.UserPortNumber</span>
<span class="c1">// import eu.timepit.refined.types.net.UserPortNumber
</span>
<span class="n">env</span><span class="o">[</span><span class="kt">UserPortNumber</span><span class="o">](</span><span class="s">"PORT"</span><span class="o">).</span>
  <span class="n">orElse</span><span class="o">(</span><span class="n">prop</span><span class="o">(</span><span class="s">"http.port"</span><span class="o">)).</span>
  <span class="n">orNone</span>
<span class="c1">// res3: ciris.ConfigValue[ciris.api.Id,Option[eu.timepit.refined.types.net.UserPortNumber]] = ConfigValue$1854337944
</span></code></pre>
</div>

<p>Putting everything together, we’re left with a more precise configuration, with validation encoded in the types.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">eu.timepit.refined.types.numeric.PosInt</span>
<span class="k">import</span> <span class="nn">eu.timepit.refined.types.string.NonEmptyString</span>

<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">ApiConfig</span><span class="o">(</span>
  <span class="n">key</span><span class="k">:</span> <span class="kt">Secret</span><span class="o">[</span><span class="kt">ApiKey</span><span class="o">],</span>
  <span class="n">port</span><span class="k">:</span> <span class="kt">UserPortNumber</span><span class="o">,</span>
  <span class="n">timeoutSeconds</span><span class="k">:</span> <span class="kt">PosInt</span>
<span class="o">)</span>

<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">Config</span><span class="o">(</span>
  <span class="n">appName</span><span class="k">:</span> <span class="kt">NonEmptyString</span><span class="o">,</span>
  <span class="n">api</span><span class="k">:</span> <span class="kt">ApiConfig</span>
<span class="o">)</span>
</code></pre>
</div>

<p>The literal, and default, configuration values are also validated at compile-time. Ciris helps you load refinement types without having to write any additional code, and we’ve already drastically reduced the risk of <em>latent configuration errors</em>.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">ciris.loadConfig</span>
<span class="c1">// import ciris.loadConfig
</span>
<span class="k">val</span> <span class="n">config</span> <span class="k">=</span>
  <span class="n">loadConfig</span><span class="o">(</span>
    <span class="n">env</span><span class="o">[</span><span class="kt">Secret</span><span class="o">[</span><span class="kt">ApiKey</span><span class="o">]](</span><span class="s">"API_KEY"</span><span class="o">).</span>
      <span class="n">orElse</span><span class="o">(</span><span class="n">prop</span><span class="o">(</span><span class="s">"api.key"</span><span class="o">)),</span>
    <span class="n">prop</span><span class="o">[</span><span class="kt">Option</span><span class="o">[</span><span class="kt">UserPortNumber</span><span class="o">]](</span><span class="s">"http.port"</span><span class="o">)</span>
  <span class="o">)</span> <span class="o">{</span> <span class="o">(</span><span class="n">apiKey</span><span class="o">,</span> <span class="n">port</span><span class="o">)</span> <span class="k">=&gt;</span>
    <span class="nc">Config</span><span class="o">(</span>
      <span class="n">appName</span> <span class="k">=</span> <span class="s">"my-api"</span><span class="o">,</span>
      <span class="n">api</span> <span class="k">=</span> <span class="nc">ApiConfig</span><span class="o">(</span>
        <span class="n">key</span> <span class="k">=</span> <span class="n">apiKey</span><span class="o">,</span>
        <span class="n">timeoutSeconds</span> <span class="k">=</span> <span class="mi">10</span><span class="o">,</span>
        <span class="n">port</span> <span class="k">=</span> <span class="n">port</span> <span class="n">getOrElse</span> <span class="mi">4000</span>
      <span class="o">)</span>
    <span class="o">)</span>
  <span class="o">}</span>
<span class="c1">// config: ciris.api.Id[Either[ciris.ConfigErrors,Config]] = Left(ConfigErrors(Combined(MissingKey(API_KEY, Environment), MissingKey(api.key, Property))))
</span></code></pre>
</div>

<h2 id="useable-configurations">Useable Configurations</h2>
<p>An interesting question arises when using refinement types: how far should we go to ensure that our configuration values are <em>useable</em>? For example, despite having restricted port numbers to <code class="highlighter-rouge">UserPortNumber</code>s, there is nothing that guarantees that the specified port is actually available, as another service might already be using the port. Being familiar with refinement types, you might be tempted to write an <code class="highlighter-rouge">OpenPort</code> predicate, which checks whether the port is open or not by creating a socket and immediately closing it.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">eu.timepit.refined.api.Validate</span>
<span class="k">import</span> <span class="nn">java.net.ServerSocket</span>

<span class="k">final</span> <span class="k">case</span> <span class="k">class</span> <span class="nc">OpenPort</span><span class="o">()</span>

<span class="k">implicit</span> <span class="k">val</span> <span class="n">openPortValidate</span><span class="k">:</span> <span class="kt">Validate.Plain</span><span class="o">[</span><span class="kt">Int</span>, <span class="kt">OpenPort</span><span class="o">]</span> <span class="k">=</span>
  <span class="nc">Validate</span><span class="o">.</span><span class="n">fromPartial</span><span class="o">(</span><span class="k">new</span> <span class="nc">ServerSocket</span><span class="o">(</span><span class="k">_</span><span class="o">).</span><span class="n">close</span><span class="o">(),</span> <span class="s">"OpenPort"</span><span class="o">,</span> <span class="nc">OpenPort</span><span class="o">())</span>
</code></pre>
</div>

<p>We’ll then check whether some <code class="highlighter-rouge">Int</code>s conform to the <code class="highlighter-rouge">OpenPort</code> predicate.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">eu.timepit.refined.refineV</span>
<span class="c1">// import eu.timepit.refined.refineV
</span>
<span class="c1">// System port number, requires sudo permissions
</span><span class="n">refineV</span><span class="o">[</span><span class="kt">OpenPort</span><span class="o">](</span><span class="mi">989</span><span class="o">)</span>
<span class="c1">// res5: Either[String,eu.timepit.refined.api.Refined[Int,OpenPort]] = Left(OpenPort predicate failed: Permission denied (Bind failed))
</span>
<span class="c1">// User port number, can be used, and is not already used
</span><span class="n">refineV</span><span class="o">[</span><span class="kt">OpenPort</span><span class="o">](</span><span class="mi">10000</span><span class="o">)</span>
<span class="c1">// res7: Either[String,eu.timepit.refined.api.Refined[Int,OpenPort]] = Right(10000)
</span>
<span class="c1">// Port number outside range, cannot be used
</span><span class="n">refineV</span><span class="o">[</span><span class="kt">OpenPort</span><span class="o">](</span><span class="mi">65536</span><span class="o">)</span>
<span class="c1">// res9: Either[String,eu.timepit.refined.api.Refined[Int,OpenPort]] = Left(OpenPort predicate failed: Port value out of range: 65536)
</span></code></pre>
</div>

<p>While this might seem like a good idea at first, when used in conjunction with the <code class="highlighter-rouge">auto</code> macro, for compile-time safe literal configuration values, we are actually performing the <code class="highlighter-rouge">OpenPort</code> check during compile-time. This means that the port values you specify in code, need to be open on the machine compiling the code, which is not what you would expect.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="n">port</span><span class="k">:</span> <span class="kt">Int</span> <span class="kt">Refined</span> <span class="kt">OpenPort</span> <span class="o">=</span> <span class="mi">989</span>
<span class="o">&lt;</span><span class="n">console</span><span class="k">&gt;:</span><span class="mi">33</span><span class="k">:</span> <span class="kt">error:</span> <span class="kt">OpenPort</span> <span class="kt">predicate</span> <span class="kt">failed:</span> <span class="kt">Permission</span> <span class="kt">denied</span> <span class="o">(</span><span class="kt">Bind</span> <span class="kt">failed</span><span class="o">)</span>
       <span class="kt">val</span> <span class="kt">port:</span> <span class="kt">Int</span> <span class="kt">Refined</span> <span class="kt">OpenPort</span> <span class="o">=</span> <span class="mi">989</span>
                                        <span class="o">^</span>
</code></pre>
</div>

<p>Maybe it’s not such a good idea to use <em>impure</em> functions in our predicates. There are still some configuration values for which we’ll have to guard against errors when using the values (binding a port number, for example). However, we can still reduce the possibility of errors by being more precise in the definition of the values. For port numbers, for example, it means that we can prevent attempts to use <em>unuseable</em> port number at compile-time (for port numbers specified in code), or as part of the configuration loading process (for port numbers loaded from the environment). If we’re able to detect unuseable configuration values as early as at compile-time, or during configuration loading, we’ve saved valuable time by preventing errors as early as possible.</p>

<p>In general, it’s recommended to only use <em>pure</em> functions in predicates, and to try and be as precise as is practically possible when defining configuration value types – you’ll have to use your own judgement when it comes to this. It might take considerable effort to create very precise predicate types, but it can also pay off in terms of fewer errors and failures. Sometimes it is enough to use a more precise type than you normally would, for example <code class="highlighter-rouge">NonEmptyString</code> instead of <code class="highlighter-rouge">String</code>, which  might not be as precise as possible, but still eliminates some invalid variants.</p>

<h2 id="external-libraries">External Libraries</h2>
<p>When interacting with other libraries, you’ll often see uses of imprecise types, like <code class="highlighter-rouge">String</code>, even though a more precise type is expected. Often there is validation logic behind the scenes, which can be extracted to a predicate type, to avoid unexpected errors. An example is the name of a <a href="https://kafka.apache.org">Kafka</a> topic, where Kafka libraries typically accept a <code class="highlighter-rouge">String</code> for the topic name, but checks to ensure that it follows some validation rules. Depending on the library, these rules may or may not be well documented, and sometimes you’ll have to dive into the <a href="https://github.com/apache/kafka/blob/6cfcc9d553622e7d511a849935e9b504f947399d/clients/src/main/java/org/apache/kafka/common/internals/Topic.java">code</a> to find them.</p>

<p>For reference, following is an example of how to express the Kafka topic name validation rules.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">def</span> <span class="n">isKafkaTopicName</span><span class="o">(</span><span class="n">topic</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span><span class="k">:</span> <span class="kt">Boolean</span> <span class="o">=</span>
  <span class="mi">1</span> <span class="o">&lt;=</span> <span class="n">topic</span><span class="o">.</span><span class="n">size</span> <span class="o">&amp;&amp;</span> <span class="n">topic</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">249</span> <span class="o">&amp;&amp;</span> <span class="o">(</span>
    <span class="n">topic</span> <span class="o">!=</span> <span class="s">"."</span> <span class="o">&amp;&amp;</span> <span class="n">topic</span> <span class="o">!=</span> <span class="s">".."</span> <span class="o">&amp;&amp;</span> <span class="o">(</span>
      <span class="n">topic</span><span class="o">.</span><span class="n">forall</span><span class="o">(</span><span class="n">c</span> <span class="k">=&gt;</span> <span class="n">c</span><span class="o">.</span><span class="n">isLetterOrDigit</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'.'</span> <span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="ss">'_' </span><span class="o">||</span> <span class="n">c</span> <span class="o">==</span> <span class="sc">'-'</span><span class="o">)</span>
    <span class="o">))</span>
</code></pre>
</div>

<p>For comparison, following is an example of how to express the validation rules with refinement types.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">import</span> <span class="nn">eu.timepit.refined.boolean.</span><span class="o">{</span><span class="nc">And</span><span class="o">,</span> <span class="nc">Not</span><span class="o">,</span> <span class="nc">Or</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">eu.timepit.refined.char.LetterOrDigit</span>
<span class="k">import</span> <span class="nn">eu.timepit.refined.collection.</span><span class="o">{</span><span class="nc">Forall</span><span class="o">,</span> <span class="nc">Size</span><span class="o">}</span>
<span class="k">import</span> <span class="nn">eu.timepit.refined.generic.Equal</span>
<span class="k">import</span> <span class="nn">eu.timepit.refined.numeric.Interval</span>

<span class="k">type</span> <span class="kt">KafkaTopicName</span> <span class="o">=</span> <span class="nc">String</span> <span class="nc">Refined</span>
  <span class="nc">And</span><span class="o">[</span><span class="kt">Size</span><span class="o">[</span><span class="kt">Interval.Closed</span><span class="o">[</span><span class="kt">W.`</span><span class="err">1</span><span class="kt">`.T</span>, <span class="kt">W.`</span><span class="err">249</span><span class="kt">`.T</span><span class="o">]]</span>,
      <span class="kt">And</span><span class="o">[</span><span class="kt">Not</span><span class="o">[</span><span class="kt">Equal</span><span class="o">[</span><span class="kt">W.`</span><span class="err">"</span><span class="kt">.</span><span class="err">"</span><span class="kt">`.T</span><span class="o">]]</span>,
          <span class="kt">And</span><span class="o">[</span><span class="kt">Not</span><span class="o">[</span><span class="kt">Equal</span><span class="o">[</span><span class="kt">W.`</span><span class="err">"</span><span class="kt">..</span><span class="err">"</span><span class="kt">`.T</span><span class="o">]]</span>,
              <span class="kt">Forall</span><span class="o">[</span><span class="kt">Or</span><span class="o">[</span><span class="kt">LetterOrDigit</span>,
                        <span class="kt">Or</span><span class="o">[</span><span class="kt">Equal</span><span class="o">[</span><span class="kt">W.`'.'`.T</span><span class="o">]</span>,
                           <span class="kt">Or</span><span class="o">[</span><span class="kt">Equal</span><span class="o">[</span><span class="kt">W.`'</span><span class="k">_</span><span class="kt">'`.T</span><span class="o">]</span>,
                              <span class="kt">Equal</span><span class="o">[</span><span class="kt">W.`'-'`.T</span><span class="o">]]]]]]]]</span>
</code></pre>
</div>

<p>Note the similarities between working at the value-level with <code class="highlighter-rouge">isKafkaTopicName</code>, and representing the same validation rules at the type-level with <code class="highlighter-rouge">KafkaTopicName</code>. While the type signature above might look complicated at first glance, there is quite often a straightforward translation between validation rules at the value-level and the equivalent rules at the type-level. Note that we instead could have chosen to represent the rules with a regular expression, both at the value-level and type-level (using the <code class="highlighter-rouge">MatchesRegex</code> predicate).</p>

<p>Kafka topic names are generally not secret, and can therefore reside as configuration values in code. With the refinement type <code class="highlighter-rouge">KafkaTopicName</code>, we benefit from being able to validate our Kafka topic names at compile-time, meaning we can be sure at compile-time that our topic names are <em>useable</em>.</p>

<div class="language-scala highlighter-rouge"><pre class="highlight"><code><span class="k">val</span> <span class="n">kafkaTopicName</span><span class="k">:</span> <span class="kt">KafkaTopicName</span> <span class="o">=</span> <span class="s">"my-topic-v2"</span>
<span class="c1">// kafkaTopicName: KafkaTopicName = my-topic-v2
</span></code></pre>
</div>

<hr />

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p>For more information on latent configuration errors, refer to the paper <a href="https://www.usenix.org/system/files/conference/osdi16/osdi16-xu.pdf">Early Detection of Configuration Errors to Reduce Failure Damage</a> and Leif Wickland’s presentation <a href="http://leifwickland.github.io/presentations/configBomb/">Defusing the Configuration Time Bomb</a> on the subject.&nbsp;<a href="#fnref:1" class="reversefootnote">&#8617;</a></p>
    </li>
  </ol>
</div>
</section></div></div></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/js/bootstrap.min.js"></script><script src="/highlight/highlight.pack.js"></script><script>hljs.configure({
languages:['scala','java','bash']
});
hljs.initHighlighting();
             </script><script src="/js/custom.js"></script><script>((window.gitter = {}).chat = {}).options = {
room: 'vlovgr/ciris'};</script><script src="https://sidecar.gitter.im/dist/sidecar.v1.js"></script><script src="/js/main.js"></script></body></html>